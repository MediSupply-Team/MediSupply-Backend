# ============================================================
# CI/CD Pipeline - Catalogo Service
# ============================================================
# Workflow para build, test y deploy automÃ¡tico del catalogo-service
# Triggers: push a main, PR a main, manual dispatch
# Steps: Tests â†’ Build â†’ Push ECR â†’ Deploy ECS

name: ðŸ›ï¸ Catalogo Service - CI/CD

on:
  # push:
  #   branches: [main]
  #   paths: 
  #     - 'catalogo-service/**'
  #     - 'infra/terraform/modules/catalogo-service/**'
  #     - '.github/workflows/catalogo-service-cicd.yml'
  # 
  # pull_request:
  #   branches: [main]
  #   paths:
  #     - 'catalogo-service/**'
  #     - 'infra/terraform/modules/catalogo-service/**'
  
  workflow_dispatch:
    inputs:
      deploy_env:
        description: 'Environment to deploy (dev/staging/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  PROJECT_NAME: medisupply
  SERVICE_NAME: catalogo-service
  AWS_REGION: us-east-1
  PYTHON_VERSION: '3.11'

jobs:
  # ============================================================
  # STAGE 1: TESTING & CODE QUALITY
  # ============================================================
  test:
    name: ðŸ§ª Tests & Quality Checks
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./catalogo-service
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ðŸ“¦ Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r test-requirements.txt
    
    - name: ðŸ” Code Quality - Flake8
      run: |
        flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: ðŸ§ª Run Unit Tests
      run: |
        python -m pytest tests/ -v --cov=app --cov-report=xml --cov-report=term
      env:
        PYTHONPATH: ${{ github.workspace }}/catalogo-service
    
    - name: ðŸ“Š Upload Coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./catalogo-service/coverage.xml
        flags: catalogo-service
        name: catalogo-service-coverage
        fail_ci_if_error: false
    
    - name: ðŸ—ï¸ Test Docker Build
      run: |
        docker build -t ${{ env.SERVICE_NAME }}:test .
        docker run --rm ${{ env.SERVICE_NAME }}:test python -c "import app; print('âœ… App imports successfully')"

  # ============================================================
  # STAGE 2: SECURITY SCANNING
  # ============================================================
  security:
    name: ðŸ”’ Security Scanning
    runs-on: ubuntu-latest
    needs: [test]
    if: github.event_name != 'pull_request'
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ðŸ” Run Trivy Vulnerability Scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: './catalogo-service'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: ðŸ“¤ Upload Trivy Results to GitHub Security
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # ============================================================
  # STAGE 3: BUILD & PUSH TO ECR
  # ============================================================
  build:
    name: ðŸ—ï¸ Build & Push ECR
    runs-on: ubuntu-latest
    needs: [test]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ðŸ·ï¸ Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.ecr-login.outputs.registry }}/${{ env.PROJECT_NAME }}-${{ github.event.inputs.deploy_env || 'dev' }}-${{ env.SERVICE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-CatalogoService
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ðŸ”‘ Login to Amazon ECR
      id: ecr-login
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: ðŸ—ï¸ Build and Push Docker Image
      id: build-image
      uses: docker/build-push-action@v5
      with:
        context: ./catalogo-service
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ============================================================
  # STAGE 4: TERRAFORM INFRASTRUCTURE
  # ============================================================
  terraform:
    name: ðŸ—ï¸ Terraform Infrastructure
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    defaults:
      run:
        working-directory: ./infra/terraform
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-Terraform-Catalogo
        aws-region: ${{ env.AWS_REGION }}
    
    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
    
    - name: ðŸ”„ Terraform Init
      run: terraform init
    
    - name: ðŸ“‹ Terraform Plan
      id: plan
      run: |
        terraform plan \
          -var="project=${{ env.PROJECT_NAME }}" \
          -var="env=${{ github.event.inputs.deploy_env || 'dev' }}" \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -out=tfplan
    
    - name: ðŸš€ Terraform Apply
      if: github.ref == 'refs/heads/main'
      run: terraform apply -auto-approve tfplan

  # ============================================================
  # STAGE 5: ECS DEPLOYMENT
  # ============================================================
  deploy:
    name: ðŸš€ Deploy to ECS
    runs-on: ubuntu-latest
    needs: [build, terraform]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-ECS-Deploy-Catalogo
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ðŸŽ¯ Get ECS Service Details
      id: ecs-service
      run: |
        CLUSTER_NAME="${{ env.PROJECT_NAME }}-${{ github.event.inputs.deploy_env || 'dev' }}-cluster"
        SERVICE_NAME="${{ env.PROJECT_NAME }}-${{ github.event.inputs.deploy_env || 'dev' }}-${{ env.SERVICE_NAME }}"
        echo "cluster-name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT
    
    - name: ðŸ“ Create ECS Task Definition
      id: task-def
      run: |
        # Get current task definition
        TASK_DEFINITION=$(aws ecs describe-task-definition \
          --task-definition ${{ steps.ecs-service.outputs.service-name }} \
          --query taskDefinition)
        
        # Update image in task definition
        NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq --arg IMAGE "${{ needs.build.outputs.image-uri }}" \
          '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
        
        echo "$NEW_TASK_DEF" > task-definition.json
        echo "task-definition=task-definition.json" >> $GITHUB_OUTPUT
    
    - name: ðŸ”„ Deploy to ECS Service
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: task-definition.json
        service: ${{ steps.ecs-service.outputs.service-name }}
        cluster: ${{ steps.ecs-service.outputs.cluster-name }}
        wait-for-service-stability: true
    
    - name: âœ… Verify Deployment
      run: |
        echo "ðŸŽ‰ Catalogo Service deployed successfully!"
        echo "ðŸ“Š Service: ${{ steps.ecs-service.outputs.service-name }}"
        echo "ðŸ—ï¸ Cluster: ${{ steps.ecs-service.outputs.cluster-name }}"
        echo "ðŸ–¼ï¸ Image: ${{ needs.build.outputs.image-uri }}"
        
        # Health check
        aws ecs describe-services \
          --cluster ${{ steps.ecs-service.outputs.cluster-name }} \
          --services ${{ steps.ecs-service.outputs.service-name }} \
          --query 'services[0].deployments[0]' \
          --output table

  # ============================================================
  # STAGE 6: POST-DEPLOYMENT TESTS
  # ============================================================
  integration-tests:
    name: ðŸ§ª Integration Tests
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ðŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-Integration-Tests
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ðŸ¥ Health Check
      run: |
        # Get ALB DNS from Terraform outputs or service discovery
        CLUSTER_NAME="${{ env.PROJECT_NAME }}-${{ github.event.inputs.deploy_env || 'dev' }}-cluster"
        SERVICE_NAME="${{ env.PROJECT_NAME }}-${{ github.event.inputs.deploy_env || 'dev' }}-${{ env.SERVICE_NAME }}"
        
        echo "â³ Waiting for service to be stable..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME
        
        echo "âœ… Service is stable and ready!"
    
    - name: ðŸ“‹ Generate Deployment Report
      if: always()
      run: |
        echo "## ðŸ“Š Catalogo Service Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
        echo "| Security Scan | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Build | âœ… Completed |" >> $GITHUB_STEP_SUMMARY
        echo "| Terraform | âœ… Applied |" >> $GITHUB_STEP_SUMMARY
        echo "| ECS Deploy | âœ… Success |" >> $GITHUB_STEP_SUMMARY
        echo "| Health Check | âœ… Healthy |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸŽ‰ **Catalogo Service deployed successfully to ${{ github.event.inputs.deploy_env || 'dev' }} environment!**" >> $GITHUB_STEP_SUMMARY