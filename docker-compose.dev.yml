# docker-compose.dev.yml  (dev contra RDS + SQS)
# Nota: puedes borrar la línea `version:`; Compose v2 la ignora.

services:
  # ---------- Infra opcional (solo si quieres DB local) ----------
  db:
    image: postgres:16-alpine
    container_name: orders-db
    profiles: ["local-db"]              # ← NO arranca por defecto
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-orders}
    ports: ["5432:5432"]
    volumes: [ "pgdata:/var/lib/postgresql/data" ]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-orders}"]
      interval: 5s
      timeout: 5s
      retries: 20
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: orders-redis
    command: >
      sh -lc 'redis-server --requirepass "${REDIS_PASSWORD:-redis}" --appendonly yes'
    environment:
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis}
    ports: ["6379:6379"]
    volumes: [ "redis_data:/data" ]
    healthcheck:
      test: ["CMD-SHELL", 'redis-cli -a "${REDIS_PASSWORD:-redis}" ping | grep PONG']
      interval: 5s
      timeout: 3s
      retries: 20
    restart: unless-stopped

  # ---------- Init de DB local (solo si usas perfil local-db) ----------
  db-init-orders:
    image: python:3.11-slim-bookworm
    profiles: ["local-db"]              # ← NO arranca por defecto
    depends_on:
      db: { condition: service_healthy }
    environment:
      PGHOST: db
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      TARGET_DB: ${POSTGRES_DB:-orders}
    volumes:
      - ./orders-service/app/create_orders_db.py:/app/create_orders_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_orders_db.py"
    restart: "no"

  # ---------- Micro de Orders (usa RDS desde .env) ----------
  orders-service:
    build:
      context: ./orders-service
    container_name: orders-service
    environment:
      PORT: ${PORT:-3000}
      DATABASE_URL: ${DATABASE_URL}      # ← RDS de tu .env
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      SQLA_ECHO: ${SQLA_ECHO:-0}
      RUN_DDL_ON_STARTUP: ${RUN_DDL_ON_STARTUP:-false}
      WEB_CONCURRENCY: ${WEB_CONCURRENCY:-1}
    working_dir: /app
    depends_on:
      redis: { condition: service_healthy }   # ← sin db ni init
    ports: ["${PORT:-3000}:${PORT:-3000}"]
    volumes:
      - ./orders-service:/app
    healthcheck:
      disable: true                           # ← evita bloqueo por falta de curl
    restart: unless-stopped

  # ---------- HAProxy (LB hacia orders-service) ----------
  haproxy:
    image: haproxy:2.9
    container_name: orders-haproxy
    volumes:
      - ./consumer-lb/app/load-balancer/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro
    command: ["haproxy","-W","-db","-f","/usr/local/etc/haproxy/haproxy.cfg"]
    ports: ["8080:8080","8404:8404"]
    depends_on:
      orders-service:
        condition: service_started           # ← no exige healthcheck
    healthcheck:
      disable: true                          # ← dev
    restart: unless-stopped

  # ---------- Consumer SQS (apunta a HAProxy) ----------
  consumer:
    image: python:3.12-slim
    container_name: orders-consumer
    working_dir: /app
    command: >
      bash -lc "
        pip install --no-cache-dir boto3==1.40.30 httpx==0.28.1 &&
        python worker.py
      "
    volumes:
      # En Windows:
      - ${USERPROFILE}/.aws:/root/.aws:ro
      # (En Linux/Mac, cambiar por: - ~/.aws:/root/.aws:ro)
      - ./consumer-lb/app/consumer/worker.py:/app/worker.py:ro
    environment:
      AWS_REGION: ${AWS_REGION:-us-east-1}
      SQS_QUEUE_URL: ${SQS_QUEUE_URL}       # ← FIFO real de AWS
      LB_TARGET_URL: http://haproxy:8080/orders
      SQS_BATCH: ${SQS_BATCH:-10}
      SQS_WAIT: ${SQS_WAIT:-20}
      SQS_VISIBILITY: ${SQS_VISIBILITY:-60}
      HTTP_TIMEOUT: ${HTTP_TIMEOUT:-30}
    depends_on:
      haproxy:
        condition: service_started
    restart: unless-stopped

  # ---------- Worker Celery (usa misma DB/Redis que orders) ----------
  worker-orders:
    build:
      context: ./orders-service
      dockerfile: Dockerfile
    container_name: worker-orders
    command: celery -A app.tasks:celery worker -l INFO --concurrency=1 --pool=solo
    environment:
      DATABASE_URL: ${DATABASE_URL}         # ← RDS
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      LOG_LEVEL: INFO
    working_dir: /app
    volumes:
      - ./orders-service:/app
    depends_on:
      redis: { condition: service_healthy }
    restart: unless-stopped

  bff-venta:
    build:
      context: ./bff-venta
      dockerfile: Dockerfile
    container_name: bff-venta
    ports:
      - "8001:8000"
    environment:
      AWS_REGION: ${AWS_REGION:-us-east-1}
      SQS_QUEUE_URL: ${SQS_QUEUE_URL}   # lo tomará de tu entorno/archivo .env
      # Si tu BFF necesita alguna URL del Orders local detrás de HAProxy, algo tipo:
      # ORDERS_BASE_URL: http://haproxy:8080
    volumes:
      # Credenciales de AWS (Windows):
      - ${USERPROFILE}/.aws:/root/.aws:ro
      # En Mac/Linux sería: - ~/.aws:/root/.aws:ro
    command: >
      gunicorn -b 0.0.0.0:8000 wsgi:app
    restart: unless-stopped

# ---------- BFF Cliente (dev contra servicios reales) ----------
  bff-cliente:
    build:
      context: ./bff-cliente
      dockerfile: Dockerfile
    container_name: bff-cliente
    ports:
      - "8002:8001"  # ⬅️ Puerto externo 8002
    environment:
      PORT: "8001"
      FLASK_ENV: ${FLASK_ENV:-development}
      AWS_REGION: ${AWS_REGION:-us-east-1}
      SQS_QUEUE_URL: ${SQS_QUEUE_URL}   # ⬅️ Cola SQS real de AWS
      
      # ⬅️ URLs de servicios internos (local)
      CLIENTE_SERVICE_URL: http://cliente-service:8000
      CATALOGO_SERVICE_URL: http://catalog-service:8080
      
      # O si prefieres apuntar a los servicios en AWS:
      # CLIENTE_SERVICE_URL: http://internal-medisupply-dev-cliente-alb-2066104303.us-east-1.elb.amazonaws.com
      # CATALOGO_SERVICE_URL: http://medisupply-dev-bff-venta-alb-1773752444.us-east-1.elb.amazonaws.com/catalog
    volumes:
      - ./bff-cliente:/app
      # Credenciales de AWS (Windows):
      - ${USERPROFILE}/.aws:/root/.aws:ro
      # En Mac/Linux: - ~/.aws:/root/.aws:ro
    command: gunicorn wsgi:app --bind 0.0.0.0:8001 --workers 2 --threads 4 --access-logfile - --error-logfile - --log-level info
    restart: unless-stopped

# ---------- Catálogo ----------
  catalog-db:
    image: postgres:16-alpine
    container_name: catalog-db
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-catalog_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-catalog_pass}
      POSTGRES_DB: catalogo
    ports:
      - "5433:5432"
    volumes:
      - catalog_pgdata:/var/lib/postgresql/data
      - ./catalogo-service/data/001_init.sql:/docker-entrypoint-initdb.d/001_init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-catalog_user} -d catalogo"]
      interval: 5s
      timeout: 5s
      retries: 10

  db-init-catalog:
    image: python:3.11-slim-bookworm
    depends_on:
      catalog-db: { condition: service_healthy }
    environment:
      PGHOST: catalog-db
      POSTGRES_USER: ${POSTGRES_USER:-catalog_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-catalog_pass}
      TARGET_DB: catalogo
    volumes:
      - ./catalogo-service/app/create_catalogo_db.py:/app/create_catalogo_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_catalogo_db.py"
    restart: "no"

  catalog-service:
    build:
      context: ./catalogo-service
      dockerfile: Dockerfile
    container_name: catalog-service
    environment:
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-catalog_user}:${POSTGRES_PASSWORD:-catalog_pass}@catalog-db:5432/catalogo
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/1
    working_dir: /app
    depends_on:
      catalog-db: { condition: service_healthy }
      redis: { condition: service_healthy }
      db-init-catalog: { condition: service_completed_successfully }
    ports: ["3001:8080"]
    volumes:
      - ./catalogo-service:/app

  # ---------- Cliente ----------
  cliente-db:
    image: postgres:16-alpine
    container_name: cliente-db
    environment:
      POSTGRES_DB: cliente_db
      POSTGRES_USER: cliente_user
      POSTGRES_PASSWORD: cliente_pass
    ports:
      - "5435:5432"
    volumes:
      - cliente_pgdata:/var/lib/postgresql/data
      - ./cliente-service/data/001_init.sql:/docker-entrypoint-initdb.d/001_init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cliente_user -d cliente_db"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  db-init-cliente:
    image: python:3.11-slim
    depends_on:
      cliente-db: { condition: service_healthy }
    environment:
      PGHOST: cliente-db
      POSTGRES_USER: cliente_user
      POSTGRES_PASSWORD: cliente_pass
      TARGET_DB: cliente_db
    volumes:
      - ./cliente-service/app/create_cliente_db.py:/app/create_cliente_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_cliente_db.py"
    restart: "no"

  cliente-service:
    build:
      context: ./cliente-service
      dockerfile: Dockerfile
    container_name: cliente-service
    environment:
      DATABASE_URL: postgresql+asyncpg://cliente_user:cliente_pass@cliente-db:5432/cliente_db
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/2
      SLA_MAX_RESPONSE_MS: 2000
      LOG_LEVEL: INFO
      DEBUG: "false"
      ORDERS_SERVICE_URL: http://orders-service:${PORT:-3000}
      CATALOGO_SERVICE_URL: http://catalog-service:8080
      ALLOWED_ORIGINS: "*"
      ALLOWED_METHODS: "*"
      ALLOWED_HEADERS: "*"
    working_dir: /app
    depends_on:
      cliente-db: { condition: service_healthy }
      redis: { condition: service_healthy }
      db-init-cliente: { condition: service_completed_successfully }
    ports: ["3003:8000"]
    volumes:
      - ./cliente-service:/app

volumes:
  pgdata:
  redis_data:
  catalog_pgdata: {}
  cliente_pgdata: {}
