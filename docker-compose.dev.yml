# docker-compose.dev.yml  (dev contra RDS + SQS)
# Nota: puedes borrar la lÃ­nea `version:`; Compose v2 la ignora.

services:
  # ---------- Infra opcional (solo si quieres DB local) ----------
  db:
    image: postgres:16-alpine
    container_name: orders-db
    profiles: ["local-db"]              # â† NO arranca por defecto
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-orders}
    ports: ["5432:5432"]
    volumes: [ "pgdata:/var/lib/postgresql/data" ]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-orders}"]
      interval: 5s
      timeout: 5s
      retries: 20
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: orders-redis
    command: >
      sh -lc 'redis-server --requirepass "${REDIS_PASSWORD:-redis}" --appendonly yes'
    environment:
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis}
    ports: ["6379:6379"]
    volumes: [ "redis_data:/data" ]
    healthcheck:
      test: ["CMD-SHELL", 'redis-cli -a "${REDIS_PASSWORD:-redis}" ping | grep PONG']
      interval: 5s
      timeout: 3s
      retries: 20
    restart: unless-stopped

  # ---------- Init de DB local (solo si usas perfil local-db) ----------
  db-init-orders:
    image: python:3.11-slim-bookworm
    profiles: ["local-db"]              # â† NO arranca por defecto
    depends_on:
      db: { condition: service_healthy }
    environment:
      PGHOST: db
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      TARGET_DB: ${POSTGRES_DB:-orders}
    volumes:
      - ./orders-service/app/create_orders_db.py:/app/create_orders_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_orders_db.py"
    restart: "no"

  # ---------- Micro de Orders (usa RDS desde .env) ----------
  orders-service:
    build:
      context: ./orders-service
    container_name: orders-service
    environment:
      PORT: ${PORT:-3000}
      DATABASE_URL: ${DATABASE_URL}      # â† RDS de tu .env
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      SQLA_ECHO: ${SQLA_ECHO:-0}
      RUN_DDL_ON_STARTUP: ${RUN_DDL_ON_STARTUP:-false}
      WEB_CONCURRENCY: ${WEB_CONCURRENCY:-1}
    working_dir: /app
    depends_on:
      redis: { condition: service_healthy }   # â† sin db ni init
    ports: ["${PORT:-3000}:${PORT:-3000}"]
    volumes:
      - ./orders-service:/app
    healthcheck:
      disable: true                           # â† evita bloqueo por falta de curl
    restart: unless-stopped

  # ---------- HAProxy (LB hacia orders-service) ----------
  haproxy:
    image: haproxy:2.9
    container_name: orders-haproxy
    volumes:
      - ./consumer-lb/app/load-balancer/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro
    command: ["haproxy","-W","-db","-f","/usr/local/etc/haproxy/haproxy.cfg"]
    ports: ["8080:8080","8404:8404"]
    depends_on:
      orders-service:
        condition: service_started           # â† no exige healthcheck
    healthcheck:
      disable: true                          # â† dev
    restart: unless-stopped

  # ---------- Consumer SQS (apunta a HAProxy) ----------
  consumer:
    image: python:3.12-slim
    container_name: orders-consumer
    working_dir: /app
    command: >
      bash -lc "
        pip install --no-cache-dir boto3==1.40.30 httpx==0.28.1 &&
        python worker.py
      "
    volumes:
      # En Windows:
      - ${USERPROFILE}/.aws:/root/.aws:ro
      # (En Linux/Mac, cambiar por: - ~/.aws:/root/.aws:ro)
      - ./consumer-lb/app/consumer/worker.py:/app/worker.py:ro
    environment:
      AWS_REGION: ${AWS_REGION:-us-east-1}
      SQS_QUEUE_URL: ${SQS_QUEUE_URL}       # â† FIFO real de AWS
      LB_TARGET_URL: http://haproxy:8080/orders
      SQS_BATCH: ${SQS_BATCH:-10}
      SQS_WAIT: ${SQS_WAIT:-20}
      SQS_VISIBILITY: ${SQS_VISIBILITY:-60}
      HTTP_TIMEOUT: ${HTTP_TIMEOUT:-30}
    depends_on:
      haproxy:
        condition: service_started
    restart: unless-stopped

  # ---------- Worker Celery (usa misma DB/Redis que orders) ----------
  worker-orders:
    build:
      context: ./orders-service
      dockerfile: Dockerfile
    container_name: worker-orders
    command: celery -A app.tasks:celery worker -l INFO --concurrency=1 --pool=solo
    environment:
      DATABASE_URL: ${DATABASE_URL}         # â† RDS
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_BROKER_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      CELERY_RESULT_BACKEND: redis://:${REDIS_PASSWORD:-redis}@redis:6379/0
      LOG_LEVEL: INFO
    working_dir: /app
    volumes:
      - ./orders-service:/app
    depends_on:
      redis: { condition: service_healthy }
    restart: unless-stopped

  bff-venta:
    build:
      context: ./bff-venta
      dockerfile: Dockerfile
    container_name: bff-venta
    ports:
      - "8001:8000"
    environment:
      AWS_REGION: ${AWS_REGION:-us-east-1}
      SQS_QUEUE_URL: ${SQS_QUEUE_URL}   # lo tomarÃ¡ de tu entorno/archivo .env
      # Si tu BFF necesita alguna URL del Orders local detrÃ¡s de HAProxy, algo tipo:
      # ORDERS_BASE_URL: http://haproxy:8080
    volumes:
      # Credenciales de AWS (Windows):
      - ${USERPROFILE}/.aws:/root/.aws:ro
      # En Mac/Linux serÃ­a: - ~/.aws:/root/.aws:ro
    command: >
      gunicorn -b 0.0.0.0:8000 wsgi:app
    restart: unless-stopped

# ---------- BFF Cliente (dev contra servicios reales) ----------
  bff-cliente:
    build:
      context: ./bff-cliente
      dockerfile: Dockerfile
    container_name: bff-cliente
    ports:
      - "8002:8001"  # â¬…ï¸ Puerto externo 8002
    environment:
      PORT: "8001"
      FLASK_ENV: ${FLASK_ENV:-development}
      AWS_REGION: ${AWS_REGION:-us-east-1}
      SQS_QUEUE_URL: ${SQS_QUEUE_URL}   # â¬…ï¸ Cola SQS real de AWS
      
      # â¬…ï¸ URLs de servicios internos (local)
      CLIENTE_SERVICE_URL: http://cliente-service:8000
      CATALOGO_SERVICE_URL: http://catalog-service:8080
      
      # O si prefieres apuntar a los servicios en AWS:
      # CLIENTE_SERVICE_URL: http://internal-medisupply-dev-cliente-alb-2066104303.us-east-1.elb.amazonaws.com
      # CATALOGO_SERVICE_URL: http://medisupply-dev-bff-venta-alb-1773752444.us-east-1.elb.amazonaws.com/catalog
    volumes:
      - ./bff-cliente:/app
      # Credenciales de AWS (Windows):
      - ${USERPROFILE}/.aws:/root/.aws:ro
      # En Mac/Linux: - ~/.aws:/root/.aws:ro
    command: gunicorn wsgi:app --bind 0.0.0.0:8001 --workers 2 --threads 4 --access-logfile - --error-logfile - --log-level info
    restart: unless-stopped

# ---------- CatÃ¡logo ----------
  catalog-db:
    image: postgres:16-alpine
    container_name: catalog-db
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-catalog_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-catalog_pass}
      POSTGRES_DB: catalogo
    ports:
      - "5433:5432"
    volumes:
      - catalog_pgdata:/var/lib/postgresql/data
      - ./catalogo-service/data/001_init.sql:/docker-entrypoint-initdb.d/001_init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-catalog_user} -d catalogo"]
      interval: 5s
      timeout: 5s
      retries: 10

  db-init-catalog:
    image: python:3.11-slim-bookworm
    depends_on:
      catalog-db: { condition: service_healthy }
    environment:
      PGHOST: catalog-db
      POSTGRES_USER: ${POSTGRES_USER:-catalog_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-catalog_pass}
      TARGET_DB: catalogo
    volumes:
      - ./catalogo-service/app/create_catalogo_db.py:/app/create_catalogo_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_catalogo_db.py"
    restart: "no"

  catalog-service:
    build:
      context: ./catalogo-service
      dockerfile: Dockerfile
    container_name: catalog-service
    entrypoint: []  # ðŸ‘ˆ AGREGAR: Bypass entrypoint
    command: uvicorn app.main:app --host 0.0.0.0 --port 3000 --reload  # ðŸ‘ˆ AGREGAR
    environment:
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-catalog_user}:${POSTGRES_PASSWORD:-catalog_pass}@catalog-db:5432/catalogo
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/1
    working_dir: /app
    depends_on:
      catalog-db: { condition: service_healthy }
      redis: { condition: service_healthy }
      db-init-catalog: { condition: service_completed_successfully }
    ports: ["3001:3000"]
    volumes:
      - ./catalogo-service:/app

  # ---------- Cliente ----------
  cliente-db:
    image: postgres:16-alpine
    container_name: cliente-db
    environment:
      POSTGRES_DB: cliente_db
      POSTGRES_USER: cliente_user
      POSTGRES_PASSWORD: cliente_pass
    ports:
      - "5435:5432"
    volumes:
      - cliente_pgdata:/var/lib/postgresql/data
      - ./cliente-service/data/001_init.sql:/docker-entrypoint-initdb.d/001_init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cliente_user -d cliente_db"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  db-init-cliente:
    image: python:3.11-slim
    depends_on:
      cliente-db: { condition: service_healthy }
    environment:
      PGHOST: cliente-db
      POSTGRES_USER: cliente_user
      POSTGRES_PASSWORD: cliente_pass
      TARGET_DB: cliente_db
    volumes:
      - ./cliente-service/app/create_cliente_db.py:/app/create_cliente_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_cliente_db.py"
    restart: "no"

  cliente-service:
    build:
      context: ./cliente-service
      dockerfile: Dockerfile
    container_name: cliente-service
    environment:
      DATABASE_URL: postgresql+asyncpg://cliente_user:cliente_pass@cliente-db:5432/cliente_db
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis}@redis:6379/2
      SLA_MAX_RESPONSE_MS: 2000
      LOG_LEVEL: INFO
      DEBUG: "false"
      ORDERS_SERVICE_URL: http://orders-service:${PORT:-3000}
      CATALOGO_SERVICE_URL: http://catalog-service:8080
      ALLOWED_ORIGINS: "*"
      ALLOWED_METHODS: "*"
      ALLOWED_HEADERS: "*"
    working_dir: /app
    depends_on:
      cliente-db: { condition: service_healthy }
      redis: { condition: service_healthy }
      db-init-cliente: { condition: service_completed_successfully }
    ports: ["3003:8000"]
    volumes:
      - ./cliente-service:/app

# ---------- Init de DB rutas ----------
  db-init-rutas:
    image: python:3.11-slim-bookworm
    profiles: ["local-db"]
    depends_on:
      db:
        condition: service_healthy
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/rutas
      PGPASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - ./ruta-service/create_rutas_db.py:/app/create_rutas_db.py:ro
      - ./ruta-service/001_add_rutas_table.sql:/tmp/migration.sql:ro
    working_dir: /app
    command: >
      bash -lc "
        apt-get update -qq && 
        apt-get install -y -qq postgresql-client &&
        pip install -q 'psycopg[binary]>=3.1,<4' && 
        python create_rutas_db.py &&
        psql -h db -U ${POSTGRES_USER} -d rutas -f /tmp/migration.sql
      "
    restart: "no"

# ---------- Ruta Service ----------
  ruta-service:
    build:
      context: ./ruta-service
      dockerfile: Dockerfile
    container_name: ruta-service
    profiles: ["local-db"]
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/rutas
      PORT: 8000
    working_dir: /app
    depends_on:
      redis:
        condition: service_healthy
      db:
        condition: service_healthy
    ports:
      - "8003:8000"
    volumes:
      - ./ruta-service:/app
    restart: unless-stopped

# Agregar despuÃ©s de db-init-rutas en docker-compose.dev.yml

  # ---------- Init de DB auth ----------
  db-init-auth:
    image: python:3.11-slim-bookworm
    profiles: ["local-db"]              # â† Mismo perfil que los demÃ¡s
    depends_on:
      db:
        condition: service_healthy
    environment:
      PGHOST: db
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      TARGET_DB: auth_db                # â† Nueva base de datos
    volumes:
      - ./auth-service/create_auth_db.py:/app/create_auth_db.py:ro
    working_dir: /app
    command: >
      bash -lc "pip install -q 'psycopg[binary]>=3.1,<4' && python create_auth_db.py"
    restart: "no"

# Agregar despuÃ©s de ruta-service en docker-compose.dev.yml

  # ---------- Auth Service ----------
  auth-service:
    build:
      context: ./auth-service
      dockerfile: Dockerfile
    container_name: auth-service
    profiles: ["local-db"]              # â† Mismo perfil
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@db:5432/auth_db
      JWT_SECRET: ${JWT_SECRET:-dev-secret-key-change-in-production}
      ENVIRONMENT: development
      LOG_LEVEL: INFO
      PORT: 8000
    working_dir: /app
    depends_on:
      db:
        condition: service_healthy
      db-init-auth:
        condition: service_completed_successfully
    ports:
      - "8004:8000"                     # â† Puerto local :8004
    volumes:
      - ./auth-service:/app
    restart: unless-stopped

volumes:
  pgdata:
  redis_data:
  catalog_pgdata: {}
  cliente_pgdata: {}
